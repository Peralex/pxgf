// Copyright 2017 Peralex Electronics (Pty) Ltd
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This example reads data from a .pxgf file containing SSNC chunks
// and outputs the sample data and the bandwidth, centre frequency,
// and sample rate to a .m file that can be read into Matlab.

#include <cmath>
#include <iostream>
#include <cinttypes>

#include "exceptions/PxgfException.h"
#include "handlers/PxgfHandlerException.h"

#include "PXGFToMatlab.h"

using namespace std;

cPXGFToMatlab::cPXGFToMatlab()
  : m_fFullScale_dBm(0.0f),
	m_fTotalGain_dB(0.0f),
	m_fFloatFullscale(1.0f),
	m_eStreamType(StreamType_Unknown),
	m_uOutputFileIndex(0)
{
	// Register all the appropriate chunk handlers
	m_PXGHandlerSIQP.registerCallbackHandler(this);
	m_PXGHandlerSSNC.registerCallbackHandler(this);
	m_PXGHandlerSSIQ.registerCallbackHandler(this);

	m_PXGHandlerCF__.registerCallbackHandler(this);
	m_PXGHandlerBW__.registerCallbackHandler(this);
	m_PXGHandlerSR__.registerCallbackHandler(this);
	m_PXGHandler_dBTG.registerCallbackHandler(this);
	m_PXGHandler_dBFS.registerCallbackHandler(this);
	m_PXGHandlerIQDC.registerCallbackHandler(this);

	m_PXGHandlerGSNC.registerCallbackHandler(this);
	m_PXGHandlerGFNC.registerCallbackHandler(this);
	m_PXGHandlerFFS_.registerCallbackHandler(this);
	m_PXGHandlerGIQP.registerCallbackHandler(this);
	m_PXGHandlerGCF_.registerCallbackHandler(this);
	m_PXGHandlerGCBW.registerCallbackHandler(this);

	m_PXGReader.registerChunkHandler(m_PXGHandlerSIQP);
	m_PXGReader.registerChunkHandler(m_PXGHandlerSSNC);
	m_PXGReader.registerChunkHandler(m_PXGHandlerSSIQ);
	m_PXGReader.registerChunkHandler(m_PXGHandlerCF__);
	m_PXGReader.registerChunkHandler(m_PXGHandlerBW__);
	m_PXGReader.registerChunkHandler(m_PXGHandlerSR__);
	m_PXGReader.registerChunkHandler(m_PXGHandler_dBTG);
	m_PXGReader.registerChunkHandler(m_PXGHandler_dBFS);
	m_PXGReader.registerChunkHandler(m_PXGHandlerIQDC);

	m_PXGReader.registerChunkHandler(m_PXGHandlerGSNC);
	m_PXGReader.registerChunkHandler(m_PXGHandlerGFNC);
	m_PXGReader.registerChunkHandler(m_PXGHandlerFFS_);
	m_PXGReader.registerChunkHandler(m_PXGHandlerGIQP);
	m_PXGReader.registerChunkHandler(m_PXGHandlerGCF_);
	m_PXGReader.registerChunkHandler(m_PXGHandlerGCBW);

	ReCalcConversionFactor();
}

cPXGFToMatlab::~cPXGFToMatlab(void)
{
}

void cPXGFToMatlab::Process(const std::string &strFileIn, const std::string &strFileOut, unsigned uNumSamples, unsigned uOffset)
{
	// Init
	m_bSIQPInit = false;
	m_bCF__Init = false;
	m_bBW__Init = false;
	m_b_dBFSInit = false;
	m_b_dBTGInit = false;
	m_bIQDCDetected = false;
	m_bSR__Init = false;

	m_fTotalGain_dB = 0.0f; // Not mandatory so assume 0
	m_fFullScale_dBm = 0.0f; // Not a mandatory chunk so assume 0
	m_fFloatFullscale = 1.0f; //assume 1.0f

	m_uSampleOffset = 0;
	m_uNumSamples = uNumSamples;
	m_uSkipSamples = uOffset;

	m_fsIn.open(strFileIn.c_str(), ios::binary);
	if(!m_fsIn) {
		cout << "Failed to open " + strFileIn << endl;
		return;
	}

	m_strFileOut = strFileOut;
	OpenNextOutputFile();

	

	try {
		// Start reading the PXGF stream (blocking until end of stream is reached).
		m_PXGReader.processStream(m_fsIn);
	}
	catch(pxgf::cPxgfException &e) {
		cout << e.toString() << endl;
	}

	m_fsOut.close();
	m_fsIn.close();
}

void cPXGFToMatlab::OpenNextOutputFile()
{
	string strNextFile = m_strFileOut + "_" + to_string(m_uOutputFileIndex) + ".m";
	m_uOutputFileIndex++;
	m_fsOut.open(strNextFile.c_str());
	if (!m_fsOut) {
		cout << "Failed to open " + strNextFile << endl;
		throw std::exception(("Failed to open " + strNextFile).c_str());
	}
	m_fsOut << "% This file is autogenerated by PXGFToMatlab application" << endl;
	m_fsOut << endl;
	m_fsOut << "pxgf_data = [" << endl;
}

void cPXGFToMatlab::CloseOutputFile()
{
	if (m_fsOut){
		m_fsOut.close();
	}
}


void cPXGFToMatlab::callbackSIQP(const pxgf::cPackingSIQP &oPacking)
{
	m_bSIQPInit = true;

	m_bIQPacked = oPacking.getIsIQPacked();
}

void cPXGFToMatlab::callbackSSNC(int64_t lTimestamp_ns, const std::vector<short> &vsIqData)
{
	if(m_bSIQPInit && m_bCF__Init && m_bBW__Init && m_bSR__Init) {
		if (m_bIQDCDetected) {
			//cycle files
			m_fsOut << "];" << endl;

			// Write meta data
			m_fsOut << "pxgf_CF_uHz = " << m_lCenterFrequency_uHz << ";" << endl;
			m_fsOut << "pxgf_SR_uHz = " << m_lSampleRate_uHz << ";" << endl;
			m_fsOut << "pxgf_BW_uHz = " << m_lBandwidth_uHz << ";" << endl;
			m_fsOut << "pxgf_TG_dB = " << m_fTotalGain_dB << ";" << endl;
			m_fsOut << "pxgf_dBFS_dBm = " << m_fFullScale_dBm << ";" << endl;
			CloseOutputFile();
			OpenNextOutputFile();
			m_bIQDCDetected = false;
		}
		vector<short>::const_iterator i = vsIqData.begin();
		if((vsIqData.size() % 2) != 0) {
			throw pxgf::cPxgfException("Received invalid SSNC chunk. Size of vector is not a multiple of 2");
		}
		while((m_uSkipSamples > 0) && (i != vsIqData.end())) {
			i += 2;
			m_uSkipSamples--;
		}
		while((m_uSampleOffset < m_uNumSamples) && (i != vsIqData.end())) {
			if(m_bIQPacked) {
				m_fsOut << (*i++) * m_fShortConversionFactor_V << " + ";
				m_fsOut << (*i++) * m_fShortConversionFactor_V << "j" << endl;
			}
			else {
				m_fsOut << (*i++) * m_fShortConversionFactor_V << "j + ";
				m_fsOut << (*i++) * m_fShortConversionFactor_V << endl;
			}
			m_uSampleOffset++;
		}
		if(m_uSampleOffset >= m_uNumSamples) {
			m_fsOut << "];" << endl;

			// Write meta data
			m_fsOut << "pxgf_CF_uHz = " << m_lCenterFrequency_uHz << ";" << endl;
			m_fsOut << "pxgf_SR_uHz = " << m_lSampleRate_uHz << ";" << endl;
			m_fsOut << "pxgf_BW_uHz = " << m_lBandwidth_uHz << ";" << endl;
			m_fsOut << "pxgf_TG_dB = " << m_fTotalGain_dB << ";" << endl;
			m_fsOut << "pxgf_dBFS_dBm = " << m_fFullScale_dBm << ";" << endl;

			throw pxgf::cPxgfException("Done");
		}
	}
	else {
		cout << "Not all descriptor chunks have been received. Discarding SSNC data." << endl;
	}
}

void cPXGFToMatlab::callbackSSIQ(int64_t lTimestamp_us, const std::vector<short> &vsIqData)
{
	callbackSSNC(lTimestamp_us * 1000, vsIqData);
}


void cPXGFToMatlab::callbackCF__(int64_t lCentreFrequency_uHz)
{
	m_lCenterFrequency_uHz = lCentreFrequency_uHz;

	m_bCF__Init = true;
}

void cPXGFToMatlab::callbackBW__(int64_t lBandwidth_uHz)
{
	m_lBandwidth_uHz = lBandwidth_uHz;
	m_bBW__Init = true;

#ifndef NDEBUG
	printf("(cPXGFToMatlab::callbackBW__) Bandwidth = %" PRId64 " Hz\n", m_lBandwidth_uHz / 1000000);
#endif
}

void cPXGFToMatlab::callback_dBFS(float f_dBFullScale_dBm)
{
	m_fFullScale_dBm = f_dBFullScale_dBm;
	m_b_dBFSInit = true;
#ifndef NDEBUG
	printf("(cPXGFToMatlab::callback_dBFS) Full Scale = %0.2f dBm\n", f_dBFullScale_dBm);
#endif
	ReCalcConversionFactor();
}

void cPXGFToMatlab::callback_dBTG(float fTotalGain_dB)
{
	m_fTotalGain_dB = fTotalGain_dB;
	m_b_dBTGInit = true;
#ifndef NDEBUG
	printf("(cPXGFToMatlab::callback_dBTG) System Gain = %0.2f dB\n", fTotalGain_dB);
#endif
	ReCalcConversionFactor();
}

void cPXGFToMatlab::callbackIQDC()
{
	m_bIQDCDetected = true;

	//throw pxgf::cPxgfException("Received discontinuity");
}

void cPXGFToMatlab::callbackSR__(int64_t lSampleRate_uHz)
{
	if(lSampleRate_uHz > 0) {
		m_lSampleRate_uHz = lSampleRate_uHz;
		m_bSR__Init = true;
	}
#ifndef NDEBUG
	printf("(cPXGFToMatlab::callbackSR__) Sample Rate = %" PRId64 " Hz\n", m_lSampleRate_uHz / 1000000);
#endif
}

void cPXGFToMatlab::ReCalcConversionFactor()
{
	// Using 50 ohm input impedance.
	// Note that the voltage of the complex input signal is fairly meaningless, as the input signal will be real.  Rather, consider the voltages calculated here
	// to be the amplitude of a complex signal which would contain the given power.
	float fSqrt_R = sqrt(50.0f/1000.0f);
	float fFullScale_dBm = m_fFullScale_dBm - m_fTotalGain_dB;
	m_fShortConversionFactor_V = fSqrt_R * powf(10.0f, fFullScale_dBm / 20.0f) / 32767.0f;
	m_fFloatConversionFactor_V = fSqrt_R * powf(10.0f, fFullScale_dBm / 20.0f) / m_fFloatFullscale;
}

void cPXGFToMatlab::callbackGSNC(int64_t lTimestamp_ns, const std::vector<short> &vsIqData)
{
	if(m_eStreamType == StreamType_Single) {
		throw pxgf::cPxgfHandlerException("Error in PXGF: Got GCBW for GSNC type stream");
	}

	if(m_bGCIQPInit && m_bGCF_Init && m_bGCBWInit && m_bSR__Init) {
		if (m_bIQDCDetected) {
			//cycle files
			m_fsOut << "];" << endl;

			// Write meta data
			m_fsOut << "pxgf_GCF_uHz = [";
			for (unsigned i = 0; i < m_vliGCF_uHz.size(); i++) {
				m_fsOut << m_vliGCF_uHz.at(i) << " ";
			}
			m_fsOut << "];" << endl;
			m_fsOut << "pxgf_SR_uHz = " << m_lSampleRate_uHz << ";" << endl;
			m_fsOut << "pxgf_BW_uHz = " << m_lBandwidth_uHz << ";" << endl;
			m_fsOut << "pxgf_TG_dB = " << m_fTotalGain_dB << ";" << endl;
			m_fsOut << "pxgf_dBFS_dBm = " << m_fFullScale_dBm << ";" << endl;
			CloseOutputFile();
			OpenNextOutputFile();
			m_bIQDCDetected = false;
		}
		// Data is written to file in columns where one column represents a single channel
		unsigned uSampleInBlock = 0;
		unsigned uNumSamplesInBlock = vsIqData.size() / (m_pGSIQPacking->getNumChannels() * 2);
		if(uNumSamplesInBlock * m_pGSIQPacking->getNumChannels() * 2 != vsIqData.size()) {
			throw pxgf::cPxgfException("Received invalid GSNC chunk. Size of vector is not a multiple of 2");
		}
		while((m_uSkipSamples > 0) && (uSampleInBlock < uNumSamplesInBlock)) {
			uSampleInBlock++;
			m_uSkipSamples--;
		}

		while((m_uSampleOffset < m_uNumSamples) && (uSampleInBlock < uNumSamplesInBlock)) {
			for(unsigned uChannel = 0; uChannel < m_pGSIQPacking->getNumChannels(); uChannel++) {
				unsigned uSampleOffset = 2 * (m_pGSIQPacking->getChannelOffsets().at(uChannel) + uSampleInBlock * m_pGSIQPacking->getIncrement());
				if(m_pGSIQPacking->getIsIQPacked()) {
					// I sample
					m_fsOut << (vsIqData.at(uSampleOffset) * m_fShortConversionFactor_V) << "+";
					// Q sample
					m_fsOut << (vsIqData.at(uSampleOffset + 1) * m_fShortConversionFactor_V) << "j ";
				}
				else {
					// I sample
					m_fsOut << (vsIqData.at(uSampleOffset + 1) * m_fShortConversionFactor_V) << "+";
					// Q sample
					m_fsOut << (vsIqData.at(uSampleOffset) * m_fShortConversionFactor_V) << "j ";
				}
			}
			m_fsOut << endl;
			m_uSampleOffset++;
			uSampleInBlock++;
		}
		if(m_uSampleOffset >= m_uNumSamples) {
			m_fsOut << "];" << endl;

			// Write meta data
			m_fsOut << "pxgf_GCF_uHz = [";
			for(unsigned i = 0; i < m_vliGCF_uHz.size(); i++) {
				m_fsOut << m_vliGCF_uHz.at(i) << " ";
			}
			m_fsOut << "];" << endl;
			m_fsOut << "pxgf_SR_uHz = " << m_lSampleRate_uHz << ";" << endl;
			m_fsOut << "pxgf_BW_uHz = " << m_lBandwidth_uHz << ";" << endl;
			m_fsOut << "pxgf_TG_dB = " << m_fTotalGain_dB << ";" << endl;
			m_fsOut << "pxgf_dBFS_dBm = " << m_fFullScale_dBm << ";" << endl;

			throw pxgf::cPxgfException("Done");
		}
		//cout << "Written out " << m_uSampleOffset << " of " << m_uNumSamples << endl;
	}
	else {
		cout << "Not all descriptor chunks have been received. Discarding GSNC data." << endl;
	}
	m_eStreamType = StreamType_Group;
}

void cPXGFToMatlab::callbackGFNC(int64_t lTimestamp_ns, const std::vector<float> &vfIqData)
{
	//cout << "(cPXGFToMatlab::callbackGFNC) vfIqData.size() = " << vfIqData.size() << endl;
	if (m_eStreamType == StreamType_Single) {
		throw pxgf::cPxgfHandlerException("Error in PXGF: Got GCBW for GFNC type stream");
	}

	if (m_bGCIQPInit && m_bGCF_Init && m_bGCBWInit && m_bSR__Init) {
		// Data is written to file in columns where one column represents a single channel
		unsigned uSampleInBlock = 0;
		unsigned uNumSamplesInBlock = vfIqData.size() / (m_pGSIQPacking->getNumChannels() * 2);
		if (uNumSamplesInBlock * m_pGSIQPacking->getNumChannels() * 2 != vfIqData.size()) {
			throw pxgf::cPxgfException("Received invalid GFNC chunk. Size of vector is not a multiple of 2");
		}
		while ((m_uSkipSamples > 0) && (uSampleInBlock < uNumSamplesInBlock)) {
			uSampleInBlock++;
			m_uSkipSamples--;
		}

		while ((m_uSampleOffset < m_uNumSamples) && (uSampleInBlock < uNumSamplesInBlock)) {
			for (unsigned uChannel = 0; uChannel < m_pGSIQPacking->getNumChannels(); uChannel++) {
				unsigned uSampleOffset = 2 * (m_pGSIQPacking->getChannelOffsets().at(uChannel) + uSampleInBlock * m_pGSIQPacking->getIncrement());
				if (m_pGSIQPacking->getIsIQPacked()) {
					// I sample
					m_fsOut << (vfIqData.at(uSampleOffset) * m_fFloatConversionFactor_V) << "+";
					// Q sample
					m_fsOut << (vfIqData.at(uSampleOffset + 1) * m_fFloatConversionFactor_V) << "j ";
				}
				else {
					// I sample
					m_fsOut << (vfIqData.at(uSampleOffset + 1) * m_fFloatConversionFactor_V) << "+";
					// Q sample
					m_fsOut << (vfIqData.at(uSampleOffset) * m_fFloatConversionFactor_V) << "j ";
				}
			}
			m_fsOut << endl;
			m_uSampleOffset++;
			uSampleInBlock++;
		}
		if (m_uSampleOffset >= m_uNumSamples) {
			
			m_fsOut << "];" << endl;

			// Write meta data
			m_fsOut << "pxgf_GCF_uHz = [";
			for (unsigned i = 0; i < m_vliGCF_uHz.size(); i++) {
				m_fsOut << m_vliGCF_uHz.at(i) << " ";
			}
			m_fsOut << "];";
			m_fsOut << "pxgf_SR_uHz = " << m_lSampleRate_uHz << ";" << endl;
			m_fsOut << "pxgf_BW_uHz = " << m_lBandwidth_uHz << ";" << endl;
			m_fsOut << "pxgf_TG_dB = " << m_fTotalGain_dB << ";" << endl;
			m_fsOut << "pxgf_dBFS_dBm = " << m_fFullScale_dBm << ";" << endl;

			CloseOutputFile();
			throw pxgf::cPxgfException("Done");
		}
	}
	else {
		cout << "Not all descriptor chunks have been received. Discarding GFNC data." << endl;
	}
	m_eStreamType = StreamType_Group;
}

void cPXGFToMatlab::callbackFFS_(float fFullscale)
{
	m_fFloatFullscale = fFullscale;
	ReCalcConversionFactor();
	
}


void cPXGFToMatlab::callbackGIQP(const pxgf::cPackingGIQP &oPacking)
{
	if(m_eStreamType == StreamType_Single) {
		throw pxgf::cPxgfHandlerException("Error in PXGF: Got GCBW for SSNC type stream");
	}
	m_pGSIQPacking = make_shared<pxgf::cPackingGIQP>(oPacking);
	m_bGCIQPInit = true;
	m_eStreamType = StreamType_Group;
}

void cPXGFToMatlab::callbackGCF_(const std::vector<int64_t> &vlCentreFrequencies_uHz)
{
	if(m_eStreamType == StreamType_Single) {
		throw pxgf::cPxgfHandlerException("Error in PXGF: Got GCBW for SSNC type stream");
	}
	m_vliGCF_uHz = vlCentreFrequencies_uHz;
	m_bGCF_Init = true;
	m_eStreamType = StreamType_Group;
}

void cPXGFToMatlab::callbackGCBW(int64_t lChannelBandwidth_uHz)
{
	if(m_eStreamType == StreamType_Single) {
		throw pxgf::cPxgfHandlerException("Error in PXGF: Got GCBW for SSNC type stream");
	}
	m_lBandwidth_uHz = lChannelBandwidth_uHz;
	m_bGCBWInit = true;
	m_eStreamType = StreamType_Group;
}
